Here are my thoughts on the "run" function. (and how I'm thinking it could work)

Lets have these two cases:

__________________________________________________________________________________________
CASE 1: NO PIPES
{

	There are no pipes, AKA there is only one command. So this enters the if(cmds==1).

	The idea here is just redirecting to all respective file decriptors and executing
		the command - simple.
	In redir_in_out all files are opened and the respective fd are dup2'ed;

	CASE 1.1:
	ls -l > file1

	So in this case we open file1 and dup2(file1, OUT), and then close it.

	----------------------------------Is currently working ---------------------------------

	CASE 1.2:
	ls -l > file1 > file2

	If we have more than one output (for example: ls -l > file1 > file2), it should:
		-Open file1,
		-Delete everything in it
		-Redirect OUT
		-Open file2
		-Delete everything in it
		-Redirect OUT
	In the end, only file 2 would have something in it. I assume it'd be the same for 
		<, << and >>

	-----------Currently it only writes to file1 and nothing happens to file2-----------------

	When everything is duped correctly, we enter the no_pipe function that has the purpose
		of executing the command (I guess I should change it's name).
	It forks the process and it simply executes the command. Meanwhile the parent is waiting,
		and when child executes, it sets STDOUT and STDIN back to normal.

}
__________________________________________________________________________________________
CASE 2: PIPES ********EXITS PROGRAM (IT SHOULDN'T)*********
{
	Here pipes are unused, AKA the number of cmds will be > 1. So this enters the while loop
		where it creates a pipe, forks the process and redirects fds.

	The idea here is that ft_pipe will create a child for each command. Each child will
		redirect all the outputs and inputs needed (which will vary depending on the type of
		command)***NEEDS WORK***;
		The parent will then redirect the input to pipe[0], and continue the loop;

	The integer "j" will be the position of the first element at the start of the arr or after
		a pipe to be used in redir_in_out. So if we have ls -l > file1 | ls -l > file2 , in the
		first loop, j=0, AKA "ls", and redir_in_out will search for <,>,<<,>> and make the redirs.
		When it reaches "|" or end of array, it will return and execute. It'll then enter another
		while loop which just increments j until it reaches a "|".The second loop will the start 
		at j=5, go into ft_pipe, fork the process, redirect fds and execute.

	CASE 2.1:
	cat file | sort

	In this case, it should works like this:
	- Redirect OUT to pipe[1]
	- Execute cat file
	- Redirect IN to pipe[0]
	- Execute sort
	- Set STDOUT back to normal

	----------------------------------Is currently working ---------------------------------

	CASE 2.2:
	ls -l > file1 | ls -l > file2

	-----------It outputs into both files but also outputs last command to terminal------------



}